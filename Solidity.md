# СИНТАКСИС И КЛЮЧЕВЫЕ СЛОВА:  

```
// Зададим версию компилятора;
pragma solidity [версия компилятоа];

// Создадим пустой контракт;
contract ContractName {
  // Код контракта;
}
```

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### ВИДЫ ХРАНИЛИЩ В SOLIDITY:  
- memory: временное хранилизе данных, аналогичен RAM.
- storage: постоянное хранилище дынных, аналог HARD DRIVE.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### ПЕРЕМЕННЫЕ И ТИПЫ ДАННЫХ:  
 - uint256: беззнаковое целочисленное, число не может быть отрицательным.
 - int: знаковое целочисленное, число может быть положительным и отрицательным.
 - uint: пседвдоним для uint256, также существуют другие варианты uint: uint32, uint16, uint8.
 - string: строчный тип данных, может содержать данные произвольной длинны в кодировке UTF-8. Должен храниться в **memory**.

**Ссылочные типы данных**: 
Существует два способа момещения данных в аргументы функции:
  1. По значению, это означает, что компилятор Solidity  создает копию  значение переменной и передает в аргумент функции. Это позволяет функции модифицировать значение не оппасаясь, что изначальное значение  переменой было модифицированно.
  2. По ссылке, это означает, что функция работает с ссылкой на оригинальное значение ( не копией). В этом случае, функция модифицирует оригинальное значение переменной.

  Значения аргументов функции желательно записывать с “_" перед именем аргумента.

```
// [тип] [имя] = [значение];
uint number = 123;
```

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### СТРУКТУРЫ:  
Структуры это сложные, комбинированные типы данных которые имеют множество значений:  

```
// создадим структуру
struct testStructure {
  // Инициалилировали переменую с типом uint именем "a";
  uint a;
  // Инициалилировали переменую с типом "string" именем "b";
  string b;
}
```
Структуры должны храниться в **memory**.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### МАССИВЫ:  
 - ```uint[3] fixedArr;```: массив фиксированной длины.
 - ```uint[] dynamicArr;```: динамический массив.
 -  ```testStructure[] public structArr;```: массив с типом данных структура. Такой тип эквивалентен сохранению данных в БД.

Если объявить массив как **public**, solidity автоматически создаст для него метод **getter**. Другие контракты могут читать данные из него, но не будут иметь право записи в этот массив. Массивы должны храниться в **memory**.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### ДОБАВЛЕНИЕ ДАННЫХ В СТРУКТУРУ И МАССИВ:  
```
// Создаем объект структуры.
testStructure qa = testStructure(1, "test");

// Добавим qa в массив structArr.
structArr.push(qa);

// Еще один вариант создания и добавления переменной в массив.
structArr.push(testStructure(1, "tester"));
```  

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### ОБЪЯВЛЕНИЕ ФУНКЦИЙ:  
```
function functionName([тип] [arg1], [тип] [arg2], [тип] [тип хранилища] [argN]) {
  // Код функции;
}
```
Например:  
```
function func1 (string memory _name, uint _number) public {
        // Код функции.
    }
```
- public: любой может обратиться к функции и выполнить её код. В Solidity по умолчанию все функции public.
- private: к этой функции есть доступ только внутри контракта, внешний доступ к этой функции недоступен. Имена **private** функций следдует с символа "_".

Если функция что-то возвращает, то мы должны это явно указать, например:  
```
// Функция вернет результат сложения целочисленных переменных.
function _sum(uint a, uint b) private returns (uint) {
  return a + b;
```
```
// Функция вернет строчный тип данных.
function greetings() public returns (string memory) {
  string greet = "Greeting from public function!";
  return greet;
```

**МОДИФИКАТОРЫ ФУНКЦИЙ**:  
- view: если функция не меняет ничего и не добавляет, то её добавляется модификатор **view**.
- pure: функция работает только с передаваемыми в неё аргументами.
- internal: функция доступна только внутри контракта и наследуемых контрактов.
- external: функция доступна только для внешних вызовов.  
- custom modifiers.

Пример **view** функции:  
```
function greeting() public view returns (string memory){
}
```

Пример **pure** функции:  
```
function add(uint a, uint b) public pure returns (uint) {
  return a + b;
}
```
Пример **internal** функции:
```
contract OtherContract {
  function internalFuncName(uint a) internal returns (uint) {
    return a++;
  }
}
```

Пример **external** функции: 

```
contract ContractName is OtherContract { // Наследование от OtherContract.
  fucntion externalFuncName() external returns (uint) { // Внешняя функция.
    return internalFuncName(1); // Вызываем функцию internalFuncName из контракта OtherContract.
  }
}
```  

Пример **custom modifiers**:  

```
modifier myModifier() {
  require(msg.sender == owner);
  _;
}
```

Пример **custom modifiers** с аргументами:  

```
modifier myModifier(uint a, uint b) {
  require(a % b == 0);
  _;
}

function c(uint a, uint b) public myModifier(4,2) returns (uint) {
  retturn a * b;
}
```


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### ПРЕОБРАЗОВАНИЕ ТИПОВ:  

Преобразование целочисленных:  
```
uint8 a = 5;
uint b = 6;

uint8 c = a * b; // Вызовет ошибку, потому что a * b вернет uint, не uint8.

uint8 c = a * uint8(b); // Мы примели b к типу uint8;

uint(keccak256(abi.encodePacked("aaaab"))); // Преобразование значения HEX в целочисленное.
```

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### KECCAC256:  

В Etherreum есть встроенная хеш функция keccak256, которая является версией SHA3. Хеш функция преобразует входящие данные в рандомное значение в HEX размером 256 бит. Важно отметить, что keccak256 принимает на вход один параметр типа bytes.Это означает, что мы должны "упаковать" параметр до передачи его на вход keccak256.

Пример:
```
//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5
keccak256(abi.encodePacked("aaaab"));
//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9
keccak256(abi.encodePacked("aaaac"));
```
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#### EVENTS (СОБЫТИЯ):  
События это способ коммуникации контракта с front-end приложение о произощедшем в blockchain. Front-end приложение прослушивает соответствующие события и выполняет действия когда они произошли.  

```
event Multiplication(uint a, uint b, uint number); // Создали событие.

function mul(uint _a, uint _b) public returns (uint) {
  uint number = _a * _b;
  emit Multiplication(_a, _b, number ); // Вызываем event;
  return number;
}
```

Код на front-end приложении:  
```
contractName.Multiplication(function(error, result) {
  // Обрабатываем ответ.
})
```

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### MAPPINGS:  
**Mapping** это key/value хранилище данных.

```
mapping (address => uint) public addressToId;

mapping (uint => string) idToUser;
```

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ:  

- msg.sender: адресс пользователя/контракта вызвавшего функцию.
- msg.value: кличество wei/eth.

 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#### KEYWORDS:  

- require: проеряет условиие и выдает ошибку если одно из требований не соблюдено.
```
owner = msg.sender;
string flag = "Verified";
function test(address _myAddress) public view returns (string) {
  require(msg.sender == _myAddress);
  return flag;
}
```
- if: условие "если".
```
uint a = 1;
uint b = 2;

function(uint a, uint b) public {
  // Function code;
  if (a == b) {
    // Function code;
  }
}
```
- for: цыкл "for".
```
uint[] numbers;
function c() public {
  for (uint i = 0; i <= 10; i++) {
    if (i % 2 == 0) {
      numbers.push(i);
    }
  rerutn numbers;
  }
}
```  



